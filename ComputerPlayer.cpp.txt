#include "Board.h"
#include "ComputerPlayer.h"
#include <iostream>

ComputerPlayer::ComputerPlayer() {}

ComputerPlayer::~ComputerPlayer() {}

void ComputerPlayer::setShootingMode(Mode mode) {
    shootingMode = mode;
}

std::pair<int, int> ComputerPlayer::chooseShootCoordinate() {
    std::cout << "Выбираем координату для выстрела. LastHit: (" << lastHit.first << ", " << lastHit.second << "), shipDirectionDetermined: " << shipDirectionDetermined << std::endl;

    if (shootingMode == Mode::INTELLIGENT) {
        if (initialHit.first == -1 && initialHit.second == -1) {
            // Стреляем рандомно, если нет первого попадания
            return randomShoot();
        }
        if (!shipDirectionDetermined) {
            // Если направление корабля не определено
            return shootAroundInitialHit();
        }
        else {
            // Если направление корабля известно
            return shootInDirection();
        }
    }
    else {
        // Случайный режим стрельбы
        return randomShoot();
    }
}

std::pair<int, int> ComputerPlayer::randomShoot() {
    int x, y;
    do {
        x = rand() % 10;
        y = rand() % 10;
    } while (opponentBoard.isCellShot(x, y));

    return std::make_pair(x, y);
}

std::pair<int, int> ComputerPlayer::shootAroundInitialHit() {
    const int dx[] = { -1,  0,  1,  0 };
    const int dy[] = { 0, -1,  0,  1 };

    std::vector<int> directions = { 0, 1, 2, 3 };

    // Eliminate directions where a shot has been made and resulted in a miss or hit a ship that's already been sunk
    for (int dir = directions.size() - 1; dir >= 0; --dir) {
        int testX = initialHit.first + dx[dir];
        int testY = initialHit.second + dy[dir];

        // Check if the direction is already shot or invalid.
        if (testX < 0 || testX >= Board::getBoardSize() || testY < 0 || testY >= Board::getBoardSize() || opponentBoard.isCellShot(testX, testY)) {
            directions.erase(directions.begin() + dir);
        }
    }

    // If directions remain, choose one to shoot around the initial hit
    if (!directions.empty()) {
        // Choose a random direction from the remaining ones
        int randomIndex = rand() % directions.size();
        int dir = directions[randomIndex];
        int newX = initialHit.first + dx[dir];
        int newY = initialHit.second + dy[dir];
        lastShotDirectionAttempted = (dx[dir] == 0) ? 'v' : 'h';
        std::cout << "Выстрел в координату (" << newX << ", " << newY << ").\n";
        return std::make_pair(newX, newY);
    }

    // If all adjacent directions have been tried, we need to reset to random shooting.
    return randomShoot();
}

std::pair<int, int> ComputerPlayer::shootInDirection() {
    int dx = 0, dy = 0;

    // Устанавливаем направление выстрела в зависимости от определенного направления корабля
    if (lastShotDirection == 'h') {
        dx = !reversedDirection ? 1 : -1;
    }
    else if (lastShotDirection == 'v') {
        dy = !reversedDirection ? 1 : -1;
    }

    int newX = lastHit.first + dx;
    int newY = lastHit.second + dy;

    // Проверяем, что следующая ячейка валидна и не была ранее обстреляна
    if (newX < 0 || newX >= Board::getBoardSize() || newY < 0 || newY >= Board::getBoardSize() || opponentBoard.isCellShot(newX, newY)) {
        // Вывод для отладки
        std::cout << "Координата для следующего выстрела (" << newX << ", " << newY << ") недействительна или уже обстреляна. Попытка смены направления стрельбы.\n";
        // Меняем направление стрельбы на противоположное
        if (!reversedDirection) {
            reversedDirection = true; // Переворачиваем направление
            lastHit = initialHit; // Возвращаемся к первому попаданию
            // Вызываем shootInDirection еще раз, чтобы найти новую цель
            return shootInDirection();
        }
        else {
            // Если уже стреляли в обратном направлении, сбрасываем стратегию
            return resetStrategyAndRandomShoot();
        }
    }
    else {
        // Вывод для отладки
        std::cout << "Выстрел в координату (" << newX << ", " << newY << ") действителен.\n";
        return std::make_pair(newX, newY);
    }
}

bool ComputerPlayer::isValidShot(int x, int y) {
    return x >= 0 && x < Board::getBoardSize() && y >= 0 && y < Board::getBoardSize() && !opponentBoard.isCellShot(x, y);
}

std::pair<int, int> ComputerPlayer::shootFromInitialHitInReversedDirection() {
    // Вычисляем новую цель в обратном направлении от начального попадания
    int dx = lastShotDirection == 'h' ? -1 : 0;
    int dy = lastShotDirection == 'v' ? -1 : 0;
    int newX = initialHit.first + dx;
    int newY = initialHit.second + dy;

    // Проверяем, что новая цель валидна
    if (isValidShot(newX, newY)) {
        return std::make_pair(newX, newY); // Возвращаем новую валидную цель
    } else {
        // Если обратное направление невалидно, сбрасываем стратегию и стреляем случайно
        return resetStrategyAndRandomShoot();
    }
}

std::pair<int, int> ComputerPlayer::resetStrategyAndRandomShoot() {
    std::cout << "Сброс стратегии стрельбы и переход к случайному выстрелу.\n";
    // Сбрасываем стратегию
    resetShootingStrategy();
    // Возвращаем случайную координату для выстрела
    return randomShoot();
}

void ComputerPlayer::placeShips() {
    // Рандомное размещение кораблей
    autoPlaceShips();
}

void ComputerPlayer::autoPlaceShips() {
    autoPlaceShipsBasic();
}

void ComputerPlayer::addSurroundingCoordinates(int x, int y) {
    const int dx[] = { -1,  0,  1,  0 };
    const int dy[] = { 0, -1,  0,  1 };

    for (int i = 0; i < 4; ++i) {
        int newX = x + dx[i];
        int newY = y + dy[i];

        if (newX >= 0 && newX < 10 && newY >= 0 && newY < 10) {
            intelligentTargets.emplace_back(newX, newY);
        }
    }
}

void ComputerPlayer::resetShootingStrategy() {
    shootingMode = Mode::RANDOM;
    lastHit = { -1, -1 };
    initialHit = { -1, -1 }; // Сброс первого попадания
    shipDirectionDetermined = false;
    reversedDirection = false; // Сброс флага обратного направления
    consecutiveHits = 0; // Сброс подсчета последовательных попаданий
    intelligentTargets.clear();
}

void ComputerPlayer::registerHit(int x, int y) {
    lastHit = { x, y }; // Обновляем последнее попадание
    std::cout << "Зарегистрировано попадание в: (" << x << ", " << y << ")." << std::endl;

    if (initialHit.first == -1 && initialHit.second == -1) {
        initialHit = lastHit; // Устанавливаем начальное попадание, если это первое попадание
        std::cout << "Начальное попадание установлено в: (" << x << ", " << y << ")." << std::endl;
    }
    else {
        // Определяем направление корабля только после второго попадания по линии с начальным попаданием
        if (!shipDirectionDetermined && (x == initialHit.first || y == initialHit.second)) {
            shipDirectionDetermined = true;
            lastShotDirection = (x == initialHit.first) ? 'v' : 'h';
            std::cout << "Определено направление корабля: " << (lastShotDirection == 'v' ? "вертикальное" : "горизонтальное") << std::endl;
        }
    }

    // Увеличиваем количество последовательных попаданий, если направление определено или это первое попадание
    if (shipDirectionDetermined || (initialHit == lastHit)) {
        consecutiveHits++;
        std::cout << "Количество последовательных попаданий увеличено: " << consecutiveHits << std::endl;
    }
}

void ComputerPlayer::registerMiss() {
    std::cout << "Зарегистрирован промах. Текущее состояние - Направление корабля определено: " << (shipDirectionDetermined ? "да" : "нет")
        << ", Обратное направление: " << (reversedDirection ? "да" : "нет") << std::endl;

    // Если направление было определено и мы еще не стреляли в обратном направлении, пытаемся его изменить
    if (shipDirectionDetermined && !reversedDirection) {
        reversedDirection = true; // Помечаем необходимость стрелять в обратном направлении
        lastHit = initialHit; // Возвращаемся к начальному попаданию, чтобы попытаться стрелять в другом направлении
        std::cout << "Изменение направления стрельбы с начального попадания." << std::endl;
    }
    else if (shipDirectionDetermined && reversedDirection) {
        // Если направление было определено и мы уже стреляли в обратном направлении, но это был промах, сбрасываем стратегию
        resetShootingStrategy(); // Сброс стратегии стрельбы
        std::cout << "Стратегия стрельбы сброшена после изменения направления и промаха." << std::endl;
    }
    // Если направление не было определено, продолжаем стрелять случайным образом
}

void ComputerPlayer::resetInitialHit() {
    initialHit = { -1, -1 };
}